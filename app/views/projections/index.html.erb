<div class="col-xs-12 col-md-9" style="height:100%;">

<!--   <div id="explain">
    As of March 20th, 2016, I am suspending work on The Fed Project. While I'd love to continue updating statements and projections,
    right now I simply don't have the time to juggle multiple side projects simultaneously. I hope to take this back up at some future date,
    but as of now I have no specific plans to do so. Thanks again for visiting!
  </div> -->

  <h1><%= number_with_delimiter(Projection.count) %></h1>
  <small>individual projections</small>
  <p>&nbsp;</p>
  <p>&nbsp;</p>
  <div id="actual-rates-chart" class="chart-div" style="display:none;">
  </div>
  <div id="combined-chart" class="chart-div">
  </div>
  <div id="long-term-projected-rates-chart" class="chart-div">
  </div>
  <div id="error-chart" class="chart-div">
  </div>
  <script>

    d3.json("http://localhost:3000/d3_get_chart_source_data.json?trim=2")
      .then(function(data) {

        actual_rates_chart = LineChart(data.actual_rates, {
          x: d => Date.parse(d.rate_date),
          y: d => Number(d.actual_rate),
          xLabel: "Date →",
          yLabel: "↑ Actual Fed funds rate (%)",
          height: 500,
          color: "steelblue",
          title: d => `${d.rate_date}: ${Number(d.actual_rate).toFixed(2)}%`
        });

        document.getElementById('actual-rates-chart').append(actual_rates_chart);




        combined_values = data.actual_rates.map(a => ({
          "date": a.rate_date,
          "series": "Actual Rate",
          "values": Number(a.actual_rate)
        }));
        combined_values = combined_values.concat(data.projected_rates.map(a => ({
          "date": a.fulfillment_date,
          "series": "Median Projection",
          "values": Number(a.median)
        })));
        combined_values = combined_values.concat(data.projected_rates.map(a => ({
          "date": a.fulfillment_date,
          "series": "Average Projection",
          "values": Number(a.avg)
        })));
        combined_values = combined_values.concat(data.projected_rates.map(a => ({
          "date": a.fulfillment_date,
          "series": "Minimum Projection",
          "values": Number(a.min)
        })));
        combined_values = combined_values.concat(data.projected_rates.map(a => ({
          "date": a.fulfillment_date,
          "series": "Maximum Projection",
          "values": Number(a.max)
        })));
  
        // console.log(combined_values);

        combined_chart = drawChart(data, {
          title: d => `${d.date}: ${Number(d.values).toFixed(2)}% (${d.series})`,
          combined_values: combined_values
        });
        document.getElementById('combined-chart').append(combined_chart);


        date_values = data.projected_long_term_rates.map(a => a.present_date);
        date_values = date_values.concat(date_values).concat(date_values).concat(date_values);

        data_values = data.projected_long_term_rates.map(a => [a.min, a.max, a.avg, a.median]);
        data_values = data_values[0].flatMap((col, i) => data_values.map(row => row[i]));

        values = date_values.map((a, index) => ({
          "dates": a,
          "values": data_values[index],
          "series": ["Minimum", "Maximum", "Average", "Median"].map(b => Array(data.projected_long_term_rates.length).fill(b, 0)).flat()[index]
        }));

        multi_line_chart = MultiLineChart(values, {
          x: d => Date.parse(d.dates),
          y: d => Number(d.values),
          z: d => d.series,
          xLabel: "Projected date →",
          yLabel: "↑ Projected long-term Fed funds rate (%)",
          height: 600,
          width: 1200,
          color: "steelblue",
          title: d => `${d.series}: ${Number(d.values).toFixed(2)}% (${d.dates})`
        });

        // focus = Generators.input(multi_line_chart);

        document.getElementById('long-term-projected-rates-chart').append(multi_line_chart);

/*
        long_term_projected_rates_chart = LineChart(data.projected_long_term_rates, {
          x: d => Date.parse(d.present_date),
          y: d => Number(d.avg),
          yLabel: "↑ Fed funds rate (%)",
          height: 500,
          color: "steelblue"
        });

        document.getElementById('long-term-projected-rates-chart').append(long_term_projected_rates_chart);*/

        error_chart = Scatterplot(data.projected_rates_detail, {
          x: d => parseInt(d.days_until),
          y: d => Number(d.projection_error),
          title: d => `Days in advance: ${d.days_until}<br>Number of projections: ${parseInt(d.projection_total)}<br>Projection error: ${d.projection_error}%`,
          xLabel: "Days in advance →",
          yLabel: "↑ Projected rate error (%)",
          stroke: "steelblue",
          width: 1200,
          height: 600
        });

        document.getElementById('error-chart').append(error_chart);

    });

    function LineChart(data, {
      x = ([x]) => x, // given d in data, returns the (temporal) x-value
      y = ([, y]) => y, // given d in data, returns the (quantitative) y-value
      title,
      defined, // for gaps in data
      curve = d3.curveLinear, // method of interpolation between points
      marginTop = 20, // top margin, in pixels
      marginRight = 30, // right margin, in pixels
      marginBottom = 30, // bottom margin, in pixels
      marginLeft = 40, // left margin, in pixels
      width = 1200, // outer width, in pixels
      height = 400, // outer height, in pixels
      xType = d3.scaleUtc, // the x-scale type
      xDomain, // [xmin, xmax]
      xRange = [marginLeft, width - marginRight], // [left, right]
      yType = d3.scaleLinear, // the y-scale type
      yDomain, // [ymin, ymax]
      yRange = [height - marginBottom, marginTop], // [bottom, top]
      yFormat =  ".2f", // a format specifier string for the y-axis
      xLabel,
      yLabel, // a label for the y-axis
      color = "currentColor", // stroke color of line
      strokeLinecap = "round", // stroke line cap of the line
      strokeLinejoin = "round", // stroke line join of the line
      strokeWidth = 1.5, // stroke width of line, in pixels
      strokeOpacity = 1, // stroke opacity of line
    } = {}) {
      // Compute values.
      const X = d3.map(data, x);
      const Y = d3.map(data, y);
      const I = d3.range(X.length);
      const O = d3.map(data, d => d);
      if (defined === undefined) defined = (d, i) => !isNaN(X[i]) && !isNaN(Y[i]);
      const D = d3.map(data, defined);

      // Compute titles.
      const T = title === undefined ? Y : title === null ? null : d3.map(data, title);

      // Compute default domains.
      if (xDomain === undefined) xDomain = d3.extent(X);
      if (yDomain === undefined) yDomain = [0, d3.max(Y)];

      // Construct scales and axes.
      const xScale = xType(xDomain, xRange);
      const yScale = yType(yDomain, yRange);
      const xAxis = d3.axisBottom(xScale).ticks(width / 80).tickSizeOuter(0);
      const yAxis = d3.axisLeft(yScale).ticks(height / 40, yFormat);

      // Construct a line generator.
      const line = d3.line()
          .defined(i => D[i])
          .curve(curve)
          .x(i => xScale(X[i]))
          .y(i => yScale(Y[i]));

      const svg = d3.create("svg")
          .attr("width", width)
          .attr("height", height)
          .attr("viewBox", [0, 0, width, height])
          .attr("style", "max-width: 100%; height: auto; height: intrinsic;")
          .on("pointerenter", pointerentered)
          .on("pointermove", pointermoved)
          .on("pointerleave", pointerleft);

      svg.append("g")
          .attr("transform", `translate(0,${height - marginBottom})`)
          .call(xAxis)
          .call(g => g.append("text")
              .attr("x", width)
              .attr("y", marginBottom - 4)
              .attr("fill", "currentColor")
              .attr("text-anchor", "end")
              .text(xLabel));

      svg.append("g")
          .attr("transform", `translate(${marginLeft},0)`)
          .call(yAxis)
          .call(g => g.select(".domain").remove())
          .call(g => g.selectAll(".tick line").clone()
              .attr("x2", width - marginLeft - marginRight)
              .attr("stroke-opacity", 0.1))
          .call(g => g.append("text")
              .attr("x", -marginLeft)
              .attr("y", 10)
              .attr("fill", "currentColor")
              .attr("text-anchor", "start")
              .text(yLabel));

      svg.append("path")
          .attr("fill", "none")
          .attr("stroke", color)
          .attr("stroke-width", strokeWidth)
          .attr("stroke-linecap", strokeLinecap)
          .attr("stroke-linejoin", strokeLinejoin)
          .attr("stroke-opacity", strokeOpacity)
          .attr("d", line(I));


      const dot = svg.append("g")
          .attr("display", "none");

      dot.append("circle")
          .attr("r", 2.5);

      dot.append("text")
          .attr("font-family", "sans-serif")
          .attr("font-size", 10)
          .attr("text-anchor", "middle")
          .attr("y", -8);

      function pointermoved(event) {
        const [xm, ym] = d3.pointer(event);
        const i = d3.least(I, i => Math.hypot(xScale(X[i]) - xm, yScale(Y[i]) - ym)); // closest point
        dot.attr("transform", `translate(${xScale(X[i])},${yScale(Y[i])})`);
        if (T) dot.select("text").text(T[i]);
        svg.property("value", O[i]).dispatch("input", {bubbles: true});
      }

      function pointerentered() {
        dot.attr("display", null);
      }

      function pointerleft() {
        dot.attr("display", "none");
        svg.node().value = null;
        svg.dispatch("input", {bubbles: true});
      }

      return svg.node();

    }

    function drawChart(data, {
      title = "hi"
    } = {}) {

      const height = 600;
      const width = 1200;
      const margin = ({top: 20, right: 30, bottom: 30, left: 40});

      const x = d3.scaleUtc()
        .domain([d3.min(data.actual_rates, d => Date.parse(d.rate_date)), d3.max(data.projected_rates, d => Date.parse(d.fulfillment_date))]) // X-axis should extend from the earliest ACTUAL interest rate date to the latest PROJECTED fulfillment_date
        .rangeRound([margin.left, width - margin.right]);

      const y = d3.scaleLinear()
        .domain([d3.max([d3.min(data.projected_rates, d => Number(d.min)), d3.min(data.actual_rates, d => Number(d.actual_rate))]), d3.max([d3.max(data.projected_rates, d => Number(d.max)), d3.max(data.actual_rates, d => Number(d.actual_rate))])]) // Y-axis should extend to the lowest and highest rates from either the projected or actual rates
        .rangeRound([height - margin.bottom, margin.top])
        .clamp(true);

      xAxis = g => g
          .attr("transform", `translate(0,${height - margin.bottom})`)
          .call(d3.axisBottom(x).ticks(width / 80))
          .call(g => g.select(".domain").remove());

      yAxis = g => g
          .attr("transform", `translate(${margin.left},0)`)
          .call(d3.axisLeft(y).ticks(null, ".2f"))
          .call(g => g.select(".domain").remove())
          .call(g => g.append("text")
              .attr("x", -margin.left)
              .attr("y", 10)
              .attr("fill", "currentColor")
              .attr("text-anchor", "start")
              .text(data.actual_rates.y));

      grid = g => g
          .attr("stroke", "currentColor")
          .attr("stroke-opacity", 0.1)
          .call(g => g.append("g")
            .selectAll("line")
            .data(x.ticks())
            .join("line")
              .attr("x1", d => 0.5 + x(d))
              .attr("x2", d => 0.5 + x(d))
              .attr("y1", margin.top)
              .attr("y2", height - margin.bottom))
          .call(g => g.append("g")
            .selectAll("line")
            .data(y.ticks())
            .join("line")
              .attr("y1", d => 0.5 + y(d))
              .attr("y2", d => 0.5 + y(d))
              .attr("x1", margin.left)
              .attr("x2", width - margin.right));

      line = d3.line()
          .x(d => x(Date.parse(d.rate_date)))
          .y(d => y(Number(d.actual_rate)));

      projected_median_line = d3.line()
          .x(d => x(Date.parse(d.fulfillment_date)))
          .y(d => y(Number(d.median)));

      projected_avg_line = d3.line()
          .x(d => x(Date.parse(d.fulfillment_date)))
          .y(d => y(Number(d.avg)));

      projected_max_line = d3.line()
          .x(d => x(Date.parse(d.fulfillment_date)))
          .y(d => y(Number(d.max)));

      projected_min_line = d3.line()
          .x(d => x(Date.parse(d.fulfillment_date)))
          .y(d => y(Number(d.min)));

      // Define the shaded area around the projected line (technically it's around the actual line too, not just the projected portion of it, but the upper and lower bound y values are equal to the line's y values, so you can't see it)
      area = d3.area()
          .x(d => x(Date.parse(d.fulfillment_date)))
          .y0(d => y(Number(d.min)))
          .y1(d => y(Number(d.max)));

      const svg = d3.create("svg")
          .attr("viewBox", [0, 0, width, height])
          .attr("font-family", "sans-serif")
          .attr("font-size", 10)
          .attr("stroke-miterlimit", 1)
          .attr("width", width)
          .attr("height", height)
          .attr("style", "max-width: 100%; height: auto; height: intrinsic;")
          .on("pointerenter", pointerentered)
          .on("pointermove", pointermoved)
          .on("pointerleave", pointerleft);

      svg.append("g")
          .call(xAxis)
          .call(g => g.append("text")
              .attr("x", width)
              .attr("y", margin.bottom - 4)
              .attr("fill", "currentColor")
              .attr("text-anchor", "end")
              .text("Date of actual or projected rate →"));

      svg.append("g")
          .call(yAxis)
          .call(g => g.append("text")
              .attr("x", -margin.left)
              .attr("y", 10)
              .attr("fill", "currentColor")
              .attr("text-anchor", "start")
              .text("↑ Fed funds rate (%)"));

      svg.append("g")
          .call(grid);

      // This is the actual data
      svg.append("path")
          .attr("fill", "steelblue")
          .attr("fill-opacity", 0.2)
          .attr("d", area(data.projected_rates));

      svg.append("path")
          .attr("fill", "none")
          .attr("stroke", "black")
          .attr("stroke-width", 1.5)
          .attr("d", line(data.actual_rates));

      svg.append("path")
          .attr("fill", "none")
          .attr("stroke", "steelblue")
          .attr("stroke-width", 1.5)
          .attr("stroke-dasharray", "3,3")
          .attr("d", projected_median_line(data.projected_rates));

      svg.append("path")
          .attr("fill", "none")
          .attr("stroke", "steelblue")
          .attr("stroke-width", 1.5)
          .attr("stroke-dasharray", "6,3")
          .attr("d", projected_avg_line(data.projected_rates));

      svg.append("path")
          .attr("fill", "none")
          .attr("stroke", "steelblue")
          .attr("stroke-width", 1.5)
          .attr("d", projected_max_line(data.projected_rates));

      svg.append("path")
          .attr("fill", "none")
          .attr("stroke", "steelblue")
          .attr("stroke-width", 1.5)
          .attr("d", projected_min_line(data.projected_rates));


      svg.append("text")
          .attr("x", x(Date.parse(data.actual_rates[data.actual_rates.length - 1].rate_date)) + 5)
          .attr("y", y(Number(data.actual_rates[data.actual_rates.length - 1].actual_rate)))
          .attr("dy", ".35em")
          .attr("text-anchor", "start")
          .style("fill", "red")
          .text("Actual Rate");

      svg.append("text")
          .attr("x", x(Date.parse(data.projected_rates[data.projected_rates.length - 1].fulfillment_date)) + 5)
          .attr("y", y(Number(data.projected_rates[data.projected_rates.length - 1].median)))
          .attr("dy", ".35em")
          .attr("text-anchor", "start")
          .style("fill", "red")
          .text("Median Projected Rate");


      svg.append("text")
          .attr("x", x(Date.parse(data.projected_rates[data.projected_rates.length - 1].fulfillment_date)) + 5)
          .attr("y", y(Number(data.projected_rates[data.projected_rates.length - 1].avg)))
          .attr("dy", ".35em")
          .attr("text-anchor", "start")
          .style("fill", "red")
          .text("Average Projected Rate");

      const dot = svg.append("g")
          .attr("display", "none");

      dot.append("circle")
          .attr("r", 2.5);

      dot.append("text")
          .attr("font-family", "sans-serif")
          .attr("font-size", 10)
          .attr("text-anchor", "middle")
          .attr("y", -8);

      function pointermoved(event) {
        const [xm, ym] = d3.pointer(event);

        // combined_dots = data.projected_rates

        const i = d3.least(combined_values, i => Math.hypot(x(Date.parse(i.date)) - xm, y(Number(i.values)) - ym)); // closest point
        // console.log(i);
        dot.attr("transform", `translate(${x(Date.parse(i.date))},${y(Number(i.values))})`);
        if (title) dot.select("text").text(title(i));
        svg.property("value", i).dispatch("input", {bubbles: true});
      }

      function pointerentered() {
        dot.attr("display", null);
      }

      function pointerleft() {
        dot.attr("display", "none");
        svg.node().value = null;
        svg.dispatch("input", {bubbles: true});
      }

      return svg.node();

/*      // This is the projected data (after April 1)
      svg.append("path")
          .attr("fill", "none")
          .attr("stroke", "steelblue")
          .attr("stroke-width", 1.5)
          .attr("stroke-dasharray", "3,3")
          .attr("d", line(data.projected_rates));

      // Create the circle around April 1
      svg.append("circle")
          .attr("cx", x(observed.date))
          .attr("cy", y(observed.mean))
          .attr("r", 2.5);

      // Create the "900" text
      svg.append("text")
          .attr("x", x(observed.date))
          .attr("y", y(observed.mean))
          .attr("dx", 6)
          .attr("dy", "0.35em")
          .text(observed.mean.toLocaleString("en"));

      // Create the "April 1" text
      svg.append("text")
          .attr("x", x(observed.date))
          .attr("y", y(observed.mean))
          .attr("dx", 6)
          .attr("dy", "1.35em")
          .text(d3.utcFormat("%B %-d")(observed.date));*/

    }

    function MultiLineChart(data, {
      x = ([x]) => x, // given d in data, returns the (temporal) x-value
      y = ([, y]) => y, // given d in data, returns the (quantitative) y-value
      z = () => 1, // given d in data, returns the (categorical) z-value
      title, // given d in data, returns the title text
      defined, // for gaps in data
      curve = d3.curveLinear, // method of interpolation between points
      marginTop = 20, // top margin, in pixels
      marginRight = 30, // right margin, in pixels
      marginBottom = 30, // bottom margin, in pixels
      marginLeft = 40, // left margin, in pixels
      width = 640, // outer width, in pixels
      height = 400, // outer height, in pixels
      xType = d3.scaleUtc, // type of x-scale
      xDomain, // [xmin, xmax]
      xRange = [marginLeft, width - marginRight], // [left, right]
      yType = d3.scaleLinear, // type of y-scale
      yDomain, // [ymin, ymax]
      yRange = [height - marginBottom, marginTop], // [bottom, top]
      yFormat, // a format specifier string for the y-axis
      xLabel,
      yLabel, // a label for the y-axis
      zDomain, // array of z-values
      color = "currentColor", // stroke color of line, as a constant or a function of *z*
      strokeLinecap, // stroke line cap of line
      strokeLinejoin, // stroke line join of line
      strokeWidth = 1.5, // stroke width of line
      strokeOpacity, // stroke opacity of line
      mixBlendMode = "multiply", // blend mode of lines
      voronoi = false // show a Voronoi overlay? (for debugging)
    } = {}) {
      // Compute values.
      const X = d3.map(data, x);
      const Y = d3.map(data, y);
      const Z = d3.map(data, z);
      const O = d3.map(data, d => d);
      if (defined === undefined) defined = (d, i) => !isNaN(X[i]) && !isNaN(Y[i]);
      const D = d3.map(data, defined);

      // Compute default domains, and unique the z-domain.
      if (xDomain === undefined) xDomain = d3.extent(X);
      if (yDomain === undefined) yDomain = [d3.max([0, d3.min(Y) - 0.5]), d3.max(Y) + 0.5];
      if (zDomain === undefined) zDomain = Z;
      zDomain = new d3.InternSet(zDomain);

      // Omit any data not present in the z-domain.
      const I = d3.range(X.length).filter(i => zDomain.has(Z[i]));

      // Construct scales and axes.
      const xScale = xType(xDomain, xRange);
      const yScale = yType(yDomain, yRange);
      const xAxis = d3.axisBottom(xScale).ticks(width / 80).tickSizeOuter(0);
      const yAxis = d3.axisLeft(yScale).ticks(height / 60, yFormat);

      // Compute titles.
      const T = title === undefined ? Z : title === null ? null : d3.map(data, title);

      // Construct a line generator.
      const line = d3.line()
          .defined(i => D[i])
          .curve(curve)
          .x(i => xScale(X[i]))
          .y(i => yScale(Y[i]));

      area = d3.area()
          .x(d => xScale(Date.parse(d[0])))
          .y0(d => yScale(Number(d[1].find(i => i.series == 'Minimum').values)))
          .y1(d => yScale(Number(d[1].find(i => i.series == 'Maximum').values)));

      const svg = d3.create("svg")
          .attr("width", width)
          .attr("height", height)
          .attr("viewBox", [0, 0, width, height])
          .attr("style", "max-width: 100%; height: auto; height: intrinsic;")
          .style("-webkit-tap-highlight-color", "transparent")
          .on("pointerenter", pointerentered)
          .on("pointermove", pointermoved)
          .on("pointerleave", pointerleft)
          .on("touchstart", event => event.preventDefault());

      // An optional Voronoi display (for fun).
      if (voronoi) svg.append("path")
          .attr("fill", "none")
          .attr("stroke", "#ccc")
          .attr("d", d3.Delaunay
            .from(I, i => xScale(X[i]), i => yScale(Y[i]))
            .voronoi([0, 0, width, height])
            .render());

      svg.append("g")
          .attr("transform", `translate(0,${height - marginBottom})`)
          .call(xAxis)
          .call(g => g.append("text")
              .attr("x", width)
              .attr("y", marginBottom - 4)
              .attr("fill", "currentColor")
              .attr("text-anchor", "end")
              .text(xLabel));

      svg.append("g")
          .attr("transform", `translate(${marginLeft},0)`)
          .call(yAxis)
          .call(g => g.select(".domain").remove())
          .call(voronoi ? () => {} : g => g.selectAll(".tick line").clone()
              .attr("x2", width - marginLeft - marginRight)
              .attr("stroke-opacity", 0.1))
          .call(g => g.append("text")
              .attr("x", -marginLeft)
              .attr("y", 10)
              .attr("fill", "currentColor")
              .attr("text-anchor", "start")
              .text(yLabel));

      const path = svg.append("g")
          .attr("fill", "none")
          .attr("stroke", typeof color === "string" ? color : null)
          .attr("stroke-linecap", strokeLinecap)
          .attr("stroke-linejoin", strokeLinejoin)
          .attr("stroke-width", strokeWidth)
          .attr("stroke-opacity", strokeOpacity)
        .selectAll("path")
        .data(d3.group(I, i => Z[i]))
        .join("path")
          .style("mix-blend-mode", mixBlendMode)
          .attr("stroke", typeof color === "function" ? ([z]) => color(z) : null)
          .attr("d", ([, I]) => line(I));

      svg.append("path")
          .attr("fill", "steelblue")
          .attr("fill-opacity", 0.2)
          .attr("d", area(d3.groups(data, i => i.dates)));

      const dot = svg.append("g")
          .attr("display", "none");

      dot.append("circle")
          .attr("r", 2.5);

      dot.append("text")
          .attr("font-family", "sans-serif")
          .attr("font-size", 10)
          .attr("text-anchor", "middle")
          .attr("y", -8);

      function pointermoved(event) {
        const [xm, ym] = d3.pointer(event);
        const i = d3.least(I, i => Math.hypot(xScale(X[i]) - xm, yScale(Y[i]) - ym)); // closest point
        path.style("stroke", ([z]) => Z[i] === z ? null : "#ddd").filter(([z]) => Z[i] === z).raise();
        dot.attr("transform", `translate(${xScale(X[i])},${yScale(Y[i])})`);
        if (T) dot.select("text").text(T[i]);
        svg.property("value", O[i]).dispatch("input", {bubbles: true});
      }

      function pointerentered() {
        path.style("mix-blend-mode", null).style("stroke", "#ddd");
        dot.attr("display", null);
      }

      function pointerleft() {
        path.style("mix-blend-mode", "multiply").style("stroke", null);
        dot.attr("display", "none");
        svg.node().value = null;
        svg.dispatch("input", {bubbles: true});
      }

      return Object.assign(svg.node(), {value: null});

    }

    function Scatterplot(data, {
      x = ([x]) => x, // given d in data, returns the (quantitative) x-value
      y = ([, y]) => y, // given d in data, returns the (quantitative) y-value
      r = 3, // (fixed) radius of dots, in pixels
      title, // given d in data, returns the title
      marginTop = 20, // top margin, in pixels
      marginRight = 30, // right margin, in pixels
      marginBottom = 30, // bottom margin, in pixels
      marginLeft = 40, // left margin, in pixels
      inset = r * 2, // inset the default range, in pixels
      insetTop = inset, // inset the default y-range
      insetRight = inset, // inset the default x-range
      insetBottom = inset, // inset the default y-range
      insetLeft = inset, // inset the default x-range
      width = 640, // outer width, in pixels
      height = 400, // outer height, in pixels
      xType = d3.scaleLinear, // type of x-scale
      xDomain, // [xmin, xmax]
      xRange = [marginLeft + insetLeft, width - marginRight - insetRight], // [left, right]
      yType = d3.scaleLinear, // type of y-scale
      yDomain, // [ymin, ymax]
      yRange = [height - marginBottom - insetBottom, marginTop + insetTop], // [bottom, top]
      xLabel, // a label for the x-axis
      yLabel, // a label for the y-axis
      xFormat, // a format specifier string for the x-axis
      yFormat, // a format specifier string for the y-axis
      fill = "transparent", // fill color for dots
      stroke = "currentColor", // stroke color for the dots
      strokeWidth = 1.5, // stroke width for dots
      halo = "#fff", // color of label halo 
      haloWidth = 3 // padding around the labels
    } = {}) {
      // Compute values.
      const X = d3.map(data, x);
      const Y = d3.map(data, y);
      const T = title == null ? null : d3.map(data, title);
      const I = d3.range(X.length).filter(i => !isNaN(X[i]) && !isNaN(Y[i]));

      // Compute default domains.
      if (xDomain === undefined) xDomain = d3.extent(X);
      if (yDomain === undefined) yDomain = d3.extent(Y);

      // Construct scales and axes.
      const xScale = xType(xDomain, xRange);
      const yScale = yType(yDomain, yRange);
      const xAxis = d3.axisBottom(xScale).ticks(width / 80, xFormat);
      const yAxis = d3.axisLeft(yScale).ticks(height / 50, yFormat);

      const svg = d3.create("svg")
          .attr("width", width)
          .attr("height", height)
          .attr("viewBox", [0, 0, width, height])
          .attr("style", "max-width: 100%; height: auto; height: intrinsic;");

      svg.append("g")
          .attr("transform", `translate(0,${height - marginBottom})`)
          .call(xAxis)
          .call(g => g.select(".domain").remove())
          .call(g => g.selectAll(".tick line").clone()
              .attr("y2", marginTop + marginBottom - height)
              .attr("stroke-opacity", 0.1))
          .call(g => g.append("text")
              .attr("x", width)
              .attr("y", marginBottom - 4)
              .attr("fill", "currentColor")
              .attr("text-anchor", "end")
              .text(xLabel));

      svg.append("g")
          .attr("transform", `translate(${marginLeft},0)`)
          .call(yAxis)
          .call(g => g.select(".domain").remove())
          .call(g => g.selectAll(".tick line").clone()
              .attr("x2", width - marginLeft - marginRight)
              .attr("stroke-opacity", 0.1))
          .call(g => g.append("text")
              .attr("x", -marginLeft)
              .attr("y", 10)
              .attr("fill", "currentColor")
              .attr("text-anchor", "start")
              .text(yLabel));


      var div = d3.select("body").append("div")
       .attr("class", "tooltip")
       .style("opacity", 0);

      svg.append("g")
          .attr("fill", fill)
          .attr("stroke", stroke)
          .attr("stroke-width", strokeWidth)
        .selectAll("circle")
        .data(I)
        .join("circle")
          .attr("cx", i => xScale(X[i]))
          .attr("cy", i => yScale(Y[i]))
          .attr("r", i => parseInt(data[i].projection_total))
        .on('pointerenter', function (d, i) {

             d3.select(this).transition()
                .duration('25')
                .attr("stroke-width", 5);

            div.transition()
              .duration('25')
              .style("opacity", 1);

        })
        .on('pointermove', function (d, i) {
          div.html(T[i])
              .style("left", (d.pageX + 10) + "px")
              .style("top", (d.pageY - 15) + "px");
        })
        .on('pointerleave', function (d, i) {
             d3.select(this).transition()
                .duration('200')
                .attr("stroke-width", strokeWidth);

              div.transition()
                .duration('200')
                .style("opacity", 0);
        });

      return svg.node();
    }

  </script>

  <%= link_to "More Details", "javascript:void(0)", :onclick => "$(showDetails())", :role => "button", class: "btn btn-info" %>
  <div id="details"></div>
  <p>
    &nbsp;
  </p>
  <script>
    function showDetails() {

      if ($('#details').is(':empty')) {
        $('#details').empty().append("<%= escape_javascript(render partial: 'details') %>").hide().slideDown('fast');
      } else {
        $('#details').slideUp('fast').empty();
      }

    }
  </script>

</div>

<div class="col-md-3 hidden-xs hidden-sm" style="height:100%;">
  <a class="twitter-timeline" data-height="800" href="https://twitter.com/TheFedProject/lists/fed-watchers?ref_src=twsrc%5Etfw">A Twitter List by TheFedProject</a> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
</div>
