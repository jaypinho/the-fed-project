<div class="col-xs-12 col-md-9" style="height:100%;">

<!--   <div id="explain">
    As of March 20th, 2016, I am suspending work on The Fed Project. While I'd love to continue updating statements and projections,
    right now I simply don't have the time to juggle multiple side projects simultaneously. I hope to take this back up at some future date,
    but as of now I have no specific plans to do so. Thanks again for visiting!
  </div> -->

  <h1><%= number_with_delimiter(Projection.count) %></h1>
  <small>individual projections</small>
  <p>&nbsp;</p>
  <p>&nbsp;</p>
  <div id="actual-rates-chart">
  </div>
  <div id="combined-chart">
  </div>
  <div id="long-term-projected-rates-chart">
  </div>
  <script>
    function LineChart(data, {
      x = ([x]) => x, // given d in data, returns the (temporal) x-value
      y = ([, y]) => y, // given d in data, returns the (quantitative) y-value
      defined, // for gaps in data
      curve = d3.curveLinear, // method of interpolation between points
      marginTop = 20, // top margin, in pixels
      marginRight = 30, // right margin, in pixels
      marginBottom = 30, // bottom margin, in pixels
      marginLeft = 40, // left margin, in pixels
      width = 1200, // outer width, in pixels
      height = 400, // outer height, in pixels
      xType = d3.scaleUtc, // the x-scale type
      xDomain, // [xmin, xmax]
      xRange = [marginLeft, width - marginRight], // [left, right]
      yType = d3.scaleLinear, // the y-scale type
      yDomain, // [ymin, ymax]
      yRange = [height - marginBottom, marginTop], // [bottom, top]
      yFormat =  ".2f", // a format specifier string for the y-axis
      yLabel, // a label for the y-axis
      color = "currentColor", // stroke color of line
      strokeLinecap = "round", // stroke line cap of the line
      strokeLinejoin = "round", // stroke line join of the line
      strokeWidth = 1.5, // stroke width of line, in pixels
      strokeOpacity = 1, // stroke opacity of line
    } = {}) {
      // Compute values.
      const X = d3.map(data, x);
      const Y = d3.map(data, y);
      const I = d3.range(X.length);
      if (defined === undefined) defined = (d, i) => !isNaN(X[i]) && !isNaN(Y[i]);
      const D = d3.map(data, defined);

      // Compute default domains.
      if (xDomain === undefined) xDomain = d3.extent(X);
      if (yDomain === undefined) yDomain = [0, d3.max(Y)];

      // Construct scales and axes.
      const xScale = xType(xDomain, xRange);
      const yScale = yType(yDomain, yRange);
      const xAxis = d3.axisBottom(xScale).ticks(width / 80).tickSizeOuter(0);
      const yAxis = d3.axisLeft(yScale).ticks(height / 40, yFormat);

      // Construct a line generator.
      const line = d3.line()
          .defined(i => D[i])
          .curve(curve)
          .x(i => xScale(X[i]))
          .y(i => yScale(Y[i]));

      const svg = d3.create("svg")
          .attr("width", width)
          .attr("height", height)
          .attr("viewBox", [0, 0, width, height])
          .attr("style", "max-width: 100%; height: auto; height: intrinsic;");

      svg.append("g")
          .attr("transform", `translate(0,${height - marginBottom})`)
          .call(xAxis);

      svg.append("g")
          .attr("transform", `translate(${marginLeft},0)`)
          .call(yAxis)
          .call(g => g.select(".domain").remove())
          .call(g => g.selectAll(".tick line").clone()
              .attr("x2", width - marginLeft - marginRight)
              .attr("stroke-opacity", 0.1))
          .call(g => g.append("text")
              .attr("x", -marginLeft)
              .attr("y", 10)
              .attr("fill", "currentColor")
              .attr("text-anchor", "start")
              .text(yLabel));

      svg.append("path")
          .attr("fill", "none")
          .attr("stroke", color)
          .attr("stroke-width", strokeWidth)
          .attr("stroke-linecap", strokeLinecap)
          .attr("stroke-linejoin", strokeLinejoin)
          .attr("stroke-opacity", strokeOpacity)
          .attr("d", line(I));

          return svg.node();
    }

    d3.json("http://localhost:3000/d3_get_chart_source_data.json")
      .then(function(data) {

        actual_rates_chart = LineChart(data.actual_rates, {
          x: d => Date.parse(d.rate_date),
          y: d => Number(d.actual_rate),
          yLabel: "↑ Fed funds rate (%)",
          height: 500,
          color: "steelblue"
        });

        document.getElementById('actual-rates-chart').append(actual_rates_chart);

/*
        long_term_projected_rates_chart = LineChart(data.projected_long_term_rates, {
          x: d => Date.parse(d.present_date),
          y: d => Number(d.avg),
          yLabel: "↑ Fed funds rate (%)",
          height: 500,
          color: "steelblue"
        });

        document.getElementById('long-term-projected-rates-chart').append(long_term_projected_rates_chart);*/

    });


    d3.json("http://localhost:3000/d3_get_chart_source_data.json")
      .then(function(data) {
        drawChart('#combined-chart', data);
       });

    function drawChart(container, data) {

      const height = 600;
      const width = 1200;
      const margin = ({top: 20, right: 30, bottom: 30, left: 40});

      const x = d3.scaleUtc()
        .domain([d3.min(data.actual_rates, d => Date.parse(d.rate_date)), d3.max(data.projected_rates, d => Date.parse(d.fulfillment_date))]) // X-axis should extend from the earliest ACTUAL interest rate date to the latest PROJECTED fulfillment_date
        .rangeRound([margin.left, width - margin.right]);

      const y = d3.scaleLinear()
        .domain([d3.max([d3.min(data.projected_rates, d => Number(d.min)), d3.min(data.actual_rates, d => Number(d.actual_rate))]), d3.max([d3.max(data.projected_rates, d => Number(d.max)), d3.max(data.actual_rates, d => Number(d.actual_rate))])]) // Y-axis should extend to the lowest and highest rates from either the projected or actual rates
        .rangeRound([height - margin.bottom, margin.top])
        .clamp(true);

      xAxis = g => g
          .attr("transform", `translate(0,${height - margin.bottom})`)
          .call(d3.axisBottom(x).ticks(width / 80))
          .call(g => g.select(".domain").remove());

      yAxis = g => g
          .attr("transform", `translate(${margin.left},0)`)
          .call(d3.axisLeft(y).ticks(null, ".2f"))
          .call(g => g.select(".domain").remove())
          .call(g => g.append("text")
              .attr("x", -margin.left)
              .attr("y", 10)
              .attr("fill", "currentColor")
              .attr("text-anchor", "start")
              .text(data.actual_rates.y));

      grid = g => g
          .attr("stroke", "currentColor")
          .attr("stroke-opacity", 0.1)
          .call(g => g.append("g")
            .selectAll("line")
            .data(x.ticks())
            .join("line")
              .attr("x1", d => 0.5 + x(d))
              .attr("x2", d => 0.5 + x(d))
              .attr("y1", margin.top)
              .attr("y2", height - margin.bottom))
          .call(g => g.append("g")
            .selectAll("line")
            .data(y.ticks())
            .join("line")
              .attr("y1", d => 0.5 + y(d))
              .attr("y2", d => 0.5 + y(d))
              .attr("x1", margin.left)
              .attr("x2", width - margin.right));

      line = d3.line()
          .x(d => x(Date.parse(d.rate_date)))
          .y(d => y(Number(d.actual_rate)));

      projected_median_line = d3.line()
          .x(d => x(Date.parse(d.fulfillment_date)))
          .y(d => y(Number(d.median)));

      projected_avg_line = d3.line()
          .x(d => x(Date.parse(d.fulfillment_date)))
          .y(d => y(Number(d.avg)));

      // Define the shaded area around the projected line (technically it's around the actual line too, not just the projected portion of it, but the upper and lower bound y values are equal to the line's y values, so you can't see it)
      area = d3.area()
          .x(d => x(Date.parse(d.fulfillment_date)))
          .y0(d => y(Number(d.min)))
          .y1(d => y(Number(d.max)));

      const svg = d3.select(container).append("svg")
          .attr("viewBox", [0, 0, width, height])
          .attr("font-family", "sans-serif")
          .attr("font-size", 10)
          .attr("stroke-miterlimit", 1)
          .attr("width", width)
          .attr("height", height)
          .attr("style", "max-width: 100%; height: auto; height: intrinsic;");

      svg.append("g")
          .call(xAxis);

      svg.append("g")
          .call(yAxis);

      svg.append("g")
          .call(grid);

      svg.append("path")
          .attr("fill", "steelblue")
          .attr("fill-opacity", 0.2)
          .attr("d", area(data.projected_rates));

      // This is the actual data
      svg.append("path")
          .attr("fill", "none")
          .attr("stroke", "black")
          .attr("stroke-width", 1.5)
          .attr("d", line(data.actual_rates));

      svg.append("path")
          .attr("fill", "none")
          .attr("stroke", "steelblue")
          .attr("stroke-width", 1.5)
          .attr("stroke-dasharray", "3,3")
          .attr("d", projected_median_line(data.projected_rates));

      svg.append("path")
          .attr("fill", "none")
          .attr("stroke", "steelblue")
          .attr("stroke-width", 1.5)
          .attr("stroke-dasharray", "6,3")
          .attr("d", projected_avg_line(data.projected_rates));


      svg.append("text")
          .attr("x", x(Date.parse(data.actual_rates[data.actual_rates.length - 1].rate_date)) + 5)
          .attr("y", y(Number(data.actual_rates[data.actual_rates.length - 1].actual_rate)))
          .attr("dy", ".35em")
          .attr("text-anchor", "start")
          .style("fill", "red")
          .text("Actual Rate");

      svg.append("text")
          .attr("x", x(Date.parse(data.projected_rates[data.projected_rates.length - 1].fulfillment_date)) + 5)
          .attr("y", y(Number(data.projected_rates[data.projected_rates.length - 1].median)))
          .attr("dy", ".35em")
          .attr("text-anchor", "start")
          .style("fill", "red")
          .text("Median Projected Rate");


      svg.append("text")
          .attr("x", x(Date.parse(data.projected_rates[data.projected_rates.length - 1].fulfillment_date)) + 5)
          .attr("y", y(Number(data.projected_rates[data.projected_rates.length - 1].avg)))
          .attr("dy", ".35em")
          .attr("text-anchor", "start")
          .style("fill", "red")
          .text("Average Projected Rate"); 

/*      // This is the projected data (after April 1)
      svg.append("path")
          .attr("fill", "none")
          .attr("stroke", "steelblue")
          .attr("stroke-width", 1.5)
          .attr("stroke-dasharray", "3,3")
          .attr("d", line(data.projected_rates));

      // Create the circle around April 1
      svg.append("circle")
          .attr("cx", x(observed.date))
          .attr("cy", y(observed.mean))
          .attr("r", 2.5);

      // Create the "900" text
      svg.append("text")
          .attr("x", x(observed.date))
          .attr("y", y(observed.mean))
          .attr("dx", 6)
          .attr("dy", "0.35em")
          .text(observed.mean.toLocaleString("en"));

      // Create the "April 1" text
      svg.append("text")
          .attr("x", x(observed.date))
          .attr("y", y(observed.mean))
          .attr("dx", 6)
          .attr("dy", "1.35em")
          .text(d3.utcFormat("%B %-d")(observed.date));*/

    }

    function MultiLineChart(data, {
      x = ([x]) => x, // given d in data, returns the (temporal) x-value
      y = ([, y]) => y, // given d in data, returns the (quantitative) y-value
      z = () => 1, // given d in data, returns the (categorical) z-value
      title, // given d in data, returns the title text
      defined, // for gaps in data
      curve = d3.curveLinear, // method of interpolation between points
      marginTop = 20, // top margin, in pixels
      marginRight = 30, // right margin, in pixels
      marginBottom = 30, // bottom margin, in pixels
      marginLeft = 40, // left margin, in pixels
      width = 640, // outer width, in pixels
      height = 400, // outer height, in pixels
      xType = d3.scaleUtc, // type of x-scale
      xDomain, // [xmin, xmax]
      xRange = [marginLeft, width - marginRight], // [left, right]
      yType = d3.scaleLinear, // type of y-scale
      yDomain, // [ymin, ymax]
      yRange = [height - marginBottom, marginTop], // [bottom, top]
      yFormat, // a format specifier string for the y-axis
      yLabel, // a label for the y-axis
      zDomain, // array of z-values
      color = "currentColor", // stroke color of line, as a constant or a function of *z*
      strokeLinecap, // stroke line cap of line
      strokeLinejoin, // stroke line join of line
      strokeWidth = 1.5, // stroke width of line
      strokeOpacity, // stroke opacity of line
      mixBlendMode = "multiply", // blend mode of lines
      voronoi = false // show a Voronoi overlay? (for debugging)
    } = {}) {
      // Compute values.
      const X = d3.map(data, x);
      const Y = d3.map(data, y);
      const Z = d3.map(data, z);
      const O = d3.map(data, d => d);
      if (defined === undefined) defined = (d, i) => !isNaN(X[i]) && !isNaN(Y[i]);
      const D = d3.map(data, defined);

      // Compute default domains, and unique the z-domain.
      if (xDomain === undefined) xDomain = d3.extent(X);
      if (yDomain === undefined) yDomain = [0, d3.max(Y)];
      if (zDomain === undefined) zDomain = Z;
      zDomain = new d3.InternSet(zDomain);

      // Omit any data not present in the z-domain.
      const I = d3.range(X.length).filter(i => zDomain.has(Z[i]));

      // Construct scales and axes.
      const xScale = xType(xDomain, xRange);
      const yScale = yType(yDomain, yRange);
      const xAxis = d3.axisBottom(xScale).ticks(width / 80).tickSizeOuter(0);
      const yAxis = d3.axisLeft(yScale).ticks(height / 60, yFormat);

      // Compute titles.
      const T = title === undefined ? Z : title === null ? null : d3.map(data, title);

      // Construct a line generator.
      const line = d3.line()
          .defined(i => D[i])
          .curve(curve)
          .x(i => xScale(X[i]))
          .y(i => yScale(Y[i]));

      const svg = d3.create("svg")
          .attr("width", width)
          .attr("height", height)
          .attr("viewBox", [0, 0, width, height])
          .attr("style", "max-width: 100%; height: auto; height: intrinsic;")
          .style("-webkit-tap-highlight-color", "transparent")
          .on("pointerenter", pointerentered)
          .on("pointermove", pointermoved)
          .on("pointerleave", pointerleft)
          .on("touchstart", event => event.preventDefault());

      // An optional Voronoi display (for fun).
      if (voronoi) svg.append("path")
          .attr("fill", "none")
          .attr("stroke", "#ccc")
          .attr("d", d3.Delaunay
            .from(I, i => xScale(X[i]), i => yScale(Y[i]))
            .voronoi([0, 0, width, height])
            .render());

      svg.append("g")
          .attr("transform", `translate(0,${height - marginBottom})`)
          .call(xAxis);

      svg.append("g")
          .attr("transform", `translate(${marginLeft},0)`)
          .call(yAxis)
          .call(g => g.select(".domain").remove())
          .call(voronoi ? () => {} : g => g.selectAll(".tick line").clone()
              .attr("x2", width - marginLeft - marginRight)
              .attr("stroke-opacity", 0.1))
          .call(g => g.append("text")
              .attr("x", -marginLeft)
              .attr("y", 10)
              .attr("fill", "currentColor")
              .attr("text-anchor", "start")
              .text(yLabel));

      const path = svg.append("g")
          .attr("fill", "none")
          .attr("stroke", typeof color === "string" ? color : null)
          .attr("stroke-linecap", strokeLinecap)
          .attr("stroke-linejoin", strokeLinejoin)
          .attr("stroke-width", strokeWidth)
          .attr("stroke-opacity", strokeOpacity)
        .selectAll("path")
        .data(d3.group(I, i => Z[i]))
        .join("path")
          .style("mix-blend-mode", mixBlendMode)
          .attr("stroke", typeof color === "function" ? ([z]) => color(z) : null)
          .attr("d", ([, I]) => line(I));

      const dot = svg.append("g")
          .attr("display", "none");

      dot.append("circle")
          .attr("r", 2.5);

      dot.append("text")
          .attr("font-family", "sans-serif")
          .attr("font-size", 10)
          .attr("text-anchor", "middle")
          .attr("y", -8);

      function pointermoved(event) {
        const [xm, ym] = d3.pointer(event);
        const i = d3.least(I, i => Math.hypot(xScale(X[i]) - xm, yScale(Y[i]) - ym)); // closest point
        path.style("stroke", ([z]) => Z[i] === z ? null : "#ddd").filter(([z]) => Z[i] === z).raise();
        dot.attr("transform", `translate(${xScale(X[i])},${yScale(Y[i])})`);
        if (T) dot.select("text").text(T[i]);
        svg.property("value", O[i]).dispatch("input", {bubbles: true});
      }

      function pointerentered() {
        path.style("mix-blend-mode", null).style("stroke", "#ddd");
        dot.attr("display", null);
      }

      function pointerleft() {
        path.style("mix-blend-mode", "multiply").style("stroke", null);
        dot.attr("display", "none");
        svg.node().value = null;
        svg.dispatch("input", {bubbles: true});
      }

      return Object.assign(svg.node(), {value: null});

    }


    d3.json("http://localhost:3000/d3_get_chart_source_data.json")
      .then(function(data) {

/*        long_term_projected_rates_chart = LineChart(data.projected_long_term_rates, {
          x: d => Date.parse(d.present_date),
          y: d => Number(d.avg),
          yLabel: "↑ Fed funds rate (%)",
          height: 500,
          color: "steelblue"
        });*/


        date_values = data.projected_long_term_rates.map(a => a.present_date);
        date_values = date_values.concat(date_values).concat(date_values).concat(date_values);

        data_values = data.projected_long_term_rates.map(a => [a.min, a.max, a.avg, a.median]);
        data_values = data_values[0].flatMap((col, i) => data_values.map(row => row[i]));

        // console.log(data_values);

        values = date_values.map((a, index) => ({
          "dates": a,
          "values": data_values[index],
          "series": ["Minimum", "Maximum", "Average", "Median"].map(b => Array(data.projected_long_term_rates.length).fill(b, 0)).flat()[index]
        }));

        multi_line_chart = MultiLineChart(values, {
          x: d => Date.parse(d.dates),
          y: d => Number(d.values),
          z: d => d.series,
          yLabel: "↑ Fed funds rate (%)",
          height: 600,
          width: 1200,
          color: "steelblue",
          title: d => `${d.series}: ${Number(d.values).toFixed(2)}% (${d.dates})`
        });

        // focus = Generators.input(multi_line_chart);

        document.getElementById('long-term-projected-rates-chart').append(multi_line_chart);

    });

  </script>

  <span class="label label-primary">Average FOMC Projections of Long-Term Rates</span>

  <div id="long_term_chart">
  </div>

  <span class="label label-primary">FOMC Projections and Actual Rates</span>

  <div id="fed_chart">
  </div>

  <span class="label label-primary">FOMC Projection Discrepancies</span>

  <div id="fed_chart2">
  </div>

  <!-- <script>

    var days_in_advance = <%= raw @chart_data.collect { |x| x[:days_in_advance] } %>;
    var begin_date = <%= raw @chart_data.collect { |x| x[:date_of_projection] } %>;

    var long_term_chart = c3.generate({
      bindto: '#long_term_chart',
      data: {
        xs: {
          'Average Long-Term Projection': 'x1'
        },
        columns: [
          <%= raw ['x1'].concat(@long_run.collect { |x| x[:present_date].strftime('%Y-%m-%d') }) %>,
          <%= raw ['Average Long-Term Projection'].concat(@long_run.collect { |x| x[:long_term].to_f }) %>
        ],
        xSort: false
      },
      axis: {
        x: {
          type: 'timeseries',
          tick: {
            format: '%Y-%m-%d',
            fit: false
          },
          label: {
            text: 'Projection Dates',
            position: 'outer-right'
          }
        },
        y: {
          label: {
            text: 'Average Projected Interest Rates',
            position: 'outer-top'
          }
        }
      },
      tooltip: {
        format: {
          title: function(d) { return d3.time.format("%B %e, %Y")(d) },
          value: function(d) { return d + "%" }
        },
        grouped: false
      }
    });

    var fed_chart = c3.generate({
      bindto: '#fed_chart',
      data: {
        xs: {
          'Actual Rate': 'x1',
          'Projected Rate': 'x2'
        },
        columns: [
          <%= raw ['x1'].concat(@date_info) %>,
          <%= raw ['x2'].concat(@chart_data.collect { |x| x[:projected_date] }) %>,
          <%= raw ['Actual Rate'].concat(@rate_info) %>,
          <%= raw ['Projected Rate'].concat(@chart_data.collect { |x| x[:projected_rate] }) %>
        ],
        xSort: false,
        color: function (color, d) {
          // d will be 'id' when called for legends
          return d.id && d.id === 'Projected Rate' ? d3.rgb(color).brighter(-days_in_advance[d.index] / 365) : color;
        }
      },
      zoom: {
        enabled: true
      },
      axis: {
        x: {
          type: 'timeseries',
          tick: {
            format: '%Y-%m-%d',
            fit: false
          },
          label: {
            text: 'Dates',
            position: 'outer-right'
          }
        },
        y: {
          label: {
            text: 'Interest Rates',
            position: 'outer-top'
          }
        }
      },
      tooltip: {
        format: {
          title: function(d) { return d3.time.format("%B %e, %Y")(d) },
          name: function (name, ratio, id, index) { if(name === 'Projected Rate') { return name + " on " + begin_date[index]; } else { return name; } },
          value: function(d) { return d + "%" }
        },
        grouped: false
      }
    });

    var fed_chart2 = c3.generate({
      bindto: '#fed_chart2',
      data: {
        xs: {
          Projections: 'Projections_x',
          Regression: 'Regression_x'
        },
        columns: [
          <%= raw ['Projections_x'].concat(@chart2_data.collect { |x| x[:days_in_advance] }) %>,
          <%= raw ['Projections'].concat(@chart2_data.collect { |x| x[:projection_discrepancy] }) %>,
          ['Regression_x', <%= @regression_data[:lowest_x] %> , 0],
          ['Regression', <%= (@regression_slope * @regression_data[:lowest_x]) + @y_intercept %> , <%= @y_intercept %>]
        ],
        type: 'scatter',
        types: {
          Regression: 'line'
        },
        colors: {
          Regression: '#BCB8B8'
        }
      },
      axis: {
        x: {
          label: {
            text: 'Days from Date of Projection to Expiration',
            position: 'outer-right'
          },
          tick: {
            fit: false
          }
        },
        y: {
          label: {
            text: 'Projected vs. Actual Interest Rates Differential',
            position: 'outer-top'
          }
        }
      },
      tooltip: {
        format: {
          title: function(d) { return Math.abs(d) + " Days Prior" },
          value: function(d) { return d3.round(d, 3) + "%  Discrepancy" }
        },
        grouped: false
      },
      legend: {
        hide: ['Regression']
      }
    });

  </script> -->

  <%= form_tag({controller: 'projections', action: 'index'}, method: 'get', id: 'trim_form', class: 'form-inline') do %>
    <div class="form-group">
    <%= label_tag(:trim, "Exclude # of outliers from each projection date/expiration date combination:") %>
    <%= select_tag(:trim, options_for_select([0,1,2,3,4,5,6,7], params.has_key?(:trim) ? params[:trim].to_i : 0), class: "form-control") %>
    </div>
  <% end %>

  <%= link_to "More Details", "javascript:void(0)", :onclick => "$(showDetails())", :role => "button", class: "btn btn-info" %>
  <div id="details"></div>

  <script>
    document.getElementById('trim').addEventListener('change', function() {
      document.getElementById('trim_form').submit();
    }, false);

    function showDetails() {

      if ($('#details').is(':empty')) {
        $('#details').empty().append("<%= escape_javascript(render partial: 'details') %>").hide().slideDown('fast');
      } else {
        $('#details').slideUp('fast').empty();
      }

    }
  </script>

</div>

<div class="col-md-3 hidden-xs hidden-sm" style="height:100%;">

  <!-- <span class="label label-primary"><%= link_to "Recent Statements", statements_path, style: "all: inherit" %></span>

  <table class="table table-striped">
    <thead>
      <tr>
        <th>Name</th>
        <th>Summary</th>
        <th>Lean</th>
        <th>Date</th>
      </tr>
    </thead>
    <tbody>
      <% Statement.order(statement_date: :desc).limit(5).each do |statement| %>
      <tr>
        <td><%= link_to statement.member.name, member_path(statement.member) %></td>
        <td><%= truncate(statement.summary, length: 50, separator: ' ') %> <%= link_to '<span class="glyphicon glyphicon-paperclip"></span>'.html_safe, statement.url, :target => "_blank" %></td>
        <td><%= statement.lean %></td>
        <td><%= statement.statement_date.strftime("%b %-d") %></td>
      </tr>
      <% end %>
    </tbody>
  </table>  -->
  <a class="twitter-timeline" data-height="800" href="https://twitter.com/TheFedProject/lists/fed-watchers?ref_src=twsrc%5Etfw">A Twitter List by TheFedProject</a> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

</div>
